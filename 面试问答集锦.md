



问题来自:https://blog.csdn.net/tyk0910/article/details/80993378

## 第三方库

### Retrofit的实现与原理

https://www.jianshu.com/p/cd69c75d053e

### Glide缓存源码，加载原理

https://blog.csdn.net/guolin_blog/article/details/53759439

##系统原理

### 应用详细启动过程，设计的进程，fork新进程(Linux)

ams首先会检查应用程序的进程是否启动,没有启动的话会通过连接zygote(孵化器)维护的一个socket,fork zygote自身创建一个新的应用程序进程给这个app使用.zygote在启动的时候创建了虚拟机的实例,这个应用程序也就有了一个虚拟机的实例.还获得了binder线程池使当前进程能够通过binder线程池进行进程间通信,通过反射调用ActivityThread 的main()函数,这个函数中开启了looper循环,使得这个进程可以进行安卓机制的消息处理.

https://blog.csdn.net/itachi85/article/details/64243223

### Android两种虚拟机区别与联系

运行时库又分为核心库和ART(5.0系统之后，Dalvik虚拟机被ART取代)。核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。相较于JVM，Dalvik虚拟机是专门为移动设备定制的，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。而替代Dalvik虚拟机的ART 的机制与Dalvik 不同。**明显区别是:**在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。 联系是都是jvm虚拟机.

### 类的加载机制

http://www.importnew.com/25295.html



### ActivityThread工作原理

https://www.cnblogs.com/younghao/p/5126408.html

##语言相关

### HashMap原理，Hash冲突，并发集合

https://www.cnblogs.com/chengxiao/p/6059914.html

http://www.importnew.com/24594.html

### GC机制

https://blog.csdn.net/anjoyandroid/article/details/78609971

###Activity的onNewIntent 

在**singleTask** 或者singleTop ,singleInstance的时候,如果目标activity已经有实例存在activity栈中,这个时候启动这个activity就不会再创建新的实例了,不会再调用当前实例的onCreate方法,如果这个activity在前台会调用,onNewIntent,->onResume ,如果在后台会调用onNewIntent->onRestart()->onStart()->onResume()

###View的绘制原理 

https://www.jianshu.com/p/5ae3356014ed



###requestLayout，invalidate，postInvalidate区别与联系

invalidate和postInvalidate方法源码分析

请求重新绘制视图，调用draw

- invalidate在主线程调用

- postInvalidate是在非主线程调用

  
View的requestLayout方法 

requestLayout()方法会调用measure过程和layout过程，不会调用draw过程，也不会重新绘制任何View包括该调用者本身。



###项目架构

组件化Mvp, retrofit,rxjava2,glide,ObjectBox,OkHttp

### 项目详细优化

不new任何对象实现网络请求,智图压缩图片,删除不必要是so,减少布局层级.

###项目难点与亮点

滚轮实现时分秒限制,wms实现离线功能,组件化module直接启动,动态首页



### 网络优化，服务端与客户端两方面

- 减少接口调用,比如注册登录这2个接口,应该是注册中把登录的工作也做了,减少不必要的接口调用.
- gzip压缩.
- protobuf
- 获取合适的图片大小,告诉服务器需要的图片大小,服务器返回对应大小的图片,七牛可以坐到.使用更小的图片格式rgb565.
- 使用缓存



1. 设计模式与实际应用 
2. adb常用命令行 
3. Android消息机制 
4. 多线程同步 
5. 内存泄漏与分析 
6. 博客与GitHub 
7. AndroidP新特性
8. 微信小程序实现原理 
9. Java反射 
10. Binder机制，共享内存实现原理 
11. Android动画 
12. 混合开发 
13. 笔试（5道题，两小时）
14. 业务需求分析与建议 
15. 黑盒排序算法
16. 项目介绍 
17. Retrofit的实现与原理，封装 
18. Java泛型 
19. 设计模式与实际应用 
20. RecyclerView与ListView(缓存原理，区别联系，优缺点) 
21. ButterKnife实现原理 
22. EventBus实现原理 
23. AOP与APT 
24. RxJava 
25. 自定义LayoutManager 
26. 嵌套滑动实现原理 
27. 混合开发 
28. 微信小程序
29. View的绘制原理 
30. 第三方框架选择标准 
31. 项目难点与亮点 
32. 插件化，热修复 
33. 项目优化
34. 具体场景分析Activity的生命周期 
35. Android消息机制 
36. Bitmap内存计算，如何压缩 
37. SurfaceView与View 
38. Application生命周期 
39. Http与Https 
40. 手写单例模式 
41. 手写算法代码
42. EventBus实现原理 
43. 自定义View里，onDraw详细优化 
44. SurfaceView替换方案 
45. 高清加载巨图且支持手势缩放的实现方案 
46. 算法题目其他思路
47. 项目介绍 
48. 架构的搭建与原理 
49. MVC，MVP，MVVM模式理解与使用 
50. 微信小程序实现原理 
51. ArrayList与LinkList区别与联系 
52. HashMap源码，JDK1.8前后详细区别，负载因子，Fail-Fast机制 
53. 线程安全的集合及各自实现原理 
54. Synchronized原理 
55. Volatile实现原理 
56. 详细描述应用从点击桌面图标到首页Activity展示的流程(应用启动流程，Activity，Window创建过程) 
57. Glide加载原理 
58. 组件化
59. Fragment的懒加载实现，参数传递与保存 
60. ViewPager的缓存实现 
61. Android消息机制，post与postDelay 
62. ActivityThread工作原理 
63. 子线程访问UI的验证与后果 
64. 主线程Looper.loop为什么不会造成死循环 
65. Android里的多线程与实现原理 
66. 热修复实现方案 
67. EventBus实现原理 
68. Android内存优化与分析 
69. 类加载机制，加载过程 
70. 组件化实现方案，路由原理 
71. 单链表添加具体实现
72. 进程与线程 
73. 项目详细优化 
74. 设计模式与实际应用 
75. ListView与RecyclerView的对比 
76. 自定义View的优化 
77. 具体场景分析高并发访问服务器的解决方案
78. 项目介绍，整体框架搭建 
79. Glide加载原理，缓存方案，LRU算法 
80. Glide加载长图，图片背景变色 
81. ArrayList与LinkList区别与联系 
82. RecyclerView缓存原理，局部刷新原理 
83. Android事件分发机制 
84. 结合具体场景处理滑动冲突事件 
85. Android消息机制 
86. ActivityThread工作原理
87. EventBus实现原理 
88. View的绘制原理 
89. 热修复实现原理，解决方案 
90. 组件化具体实现 
91. 项目详细优化 
92. Android权限管理 
93. 编码风格与规范 
94. 项目管理